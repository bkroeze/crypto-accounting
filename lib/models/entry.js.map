{
  "version": 3,
  "sources": [
    "entry.js"
  ],
  "names": [
    "R",
    "require",
    "RA",
    "utils",
    "BigNumber",
    "makeError",
    "BIG_0",
    "addBigNumbers",
    "isNegativeString",
    "positiveString",
    "CREDIT",
    "DEBIT",
    "ERRORS",
    "SYMBOL_MAP",
    "LEDGER_COMMENTS",
    "LEDGER_LINE_COMMENT",
    "log",
    "get",
    "lineSpaces",
    "RegExp",
    "lineCommentSpaces",
    "tabRe",
    "commaRe",
    "isCommentToken",
    "startsWith",
    "lastTokenIsComment",
    "val",
    "last",
    "describeLots",
    "wrappers",
    "map",
    "wrapper",
    "lot",
    "toObject",
    "applied",
    "toFixed",
    "mergeProps",
    "props",
    "id",
    "transaction",
    "quantity",
    "currency",
    "account",
    "lots",
    "type",
    "note",
    "shortcut",
    "pair",
    "balancing",
    "virtual",
    "KEYS",
    "keysIn",
    "getProps",
    "pick",
    "hasCredits",
    "has",
    "hasDebits",
    "hasEntries",
    "isCredit",
    "propEq",
    "isDebit",
    "hasLeadingSymbol",
    "symbol",
    "slice",
    "looksNumeric",
    "getLotCredits",
    "filter",
    "prop",
    "splitComment",
    "cleaned",
    "replace",
    "ix",
    "indexOf",
    "tokenizeShortcut",
    "leadingSymbolMap",
    "fixLeadingSymbol",
    "token",
    "work",
    "forEach",
    "comment",
    "splitAndTrim",
    "join",
    "tokens",
    "length",
    "console",
    "error",
    "TypeError",
    "INVALID_SHORTCUT",
    "push",
    "Entry",
    "constructor",
    "isString",
    "merged",
    "JSON",
    "stringify",
    "INVALID_TERM",
    "amount",
    "key",
    "applyShortcut",
    "isNil",
    "arrayToEntries",
    "rawArray",
    "entryType",
    "entry",
    "objectToEntries",
    "raw",
    "entries",
    "debits",
    "credits",
    "concat",
    "shortcutToEntries",
    "rawShortcut",
    "accum",
    "connector",
    "current",
    "shortcuts",
    "shift",
    "isConnector",
    "debit",
    "credit",
    "debitIx",
    "creditIx",
    "firstAmount",
    "negativeFirst",
    "catcher",
    "err",
    "message",
    "detail",
    "maker",
    "makeEntry",
    "tryCatch",
    "setPair",
    "flexibleToEntries",
    "isObj",
    "makeEntries",
    "flatten",
    "pop",
    "trim",
    "numeric1",
    "numeric2",
    "applyToAccount",
    "accounts",
    "acct",
    "getAccountPath",
    "addEntry",
    "e",
    "NOT_FOUND",
    "equals",
    "is",
    "eq",
    "getAccount",
    "path",
    "getLotCreditRemaining",
    "TYPE",
    "minus",
    "getFullShortcut",
    "getUtc",
    "utc",
    "setLot",
    "maxQuantity",
    "remainingLot",
    "getRemaining",
    "remainingCredit",
    "min",
    "gt",
    "inAccount",
    "contained",
    "split",
    "inPath",
    "isBalanced",
    "isBalancingEntry",
    "makeBalancingClone",
    "multiplyBy",
    "posting",
    "times",
    "partner",
    "priceEach",
    "options",
    "shallow",
    "yaml",
    "stripFalsy",
    "toString",
    "module",
    "exports"
  ],
  "mappings": "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",
  "file": "entry.js",
  "sourceRoot": "../../src/models",
  "sourcesContent": [
    "/* eslint prefer-destructuring: [\"error\", { array: false }] */\nconst R = require('ramda');\nconst RA = require('ramda-adjunct');\n\nconst utils = require('../utils/models');\nconst BigNumber = require('bignumber.js');\nconst { makeError } = require('../utils/errors');\nconst {\n  BIG_0, addBigNumbers, isNegativeString, positiveString,\n} = require('../utils/numbers');\nconst { CREDIT, DEBIT, ERRORS, SYMBOL_MAP, LEDGER_COMMENTS, LEDGER_LINE_COMMENT } = require('./constants');\nconst log = require('js-logger').get('c.a.models.entry');\nconst lineSpaces = new RegExp(/  /, 'g');\nconst lineCommentSpaces = /\\; */;\nconst tabRe = new RegExp(/\\t/, 'g');\nconst commaRe = new RegExp(/,/, 'g');\n\nconst isCommentToken = R.startsWith(LEDGER_LINE_COMMENT);\nconst lastTokenIsComment = (val) => isCommentToken(R.last(val));\n\nfunction describeLots(wrappers) {\n  return wrappers.map(wrapper => ({\n    ...wrapper.lot.toObject(),\n    applied: wrapper.applied.toFixed(8),\n  }));\n}\n\nconst mergeProps = props => ({\n  id: null,\n  transaction: null,\n  quantity: null,\n  currency: '',\n  account: '',\n  lots: [],\n  type: DEBIT,\n  note: '',\n  shortcut: '',\n  pair: null,\n  balancing: null, // the other entry in a balancing pair\n  virtual: false,\n  ...props,\n});\n\nconst KEYS = R.keysIn(mergeProps({}));\nconst getProps = R.pick(KEYS);\nconst hasCredits = R.has('credits');\nconst hasDebits = R.has('debits');\nconst hasEntries = R.has('entries');\nconst isCredit = R.propEq('type', 'credit');\nconst isDebit = R.propEq('type', 'debit');\n\nconst hasLeadingSymbol = (symbol, val) => {\n  return val.slice(0,1) === symbol && utils.looksNumeric(val.slice(1));\n}\n\nfunction getLotCredits(currency, lots) {\n  return lots\n    .filter(R.propEq('currency', currency))\n    .map(R.prop('applied'));\n}\n\nfunction splitComment(val) {\n  const cleaned = val.replace(lineSpaces, ' ').replace(tabRe, ' ');\n\n  let ix = cleaned.indexOf(LEDGER_LINE_COMMENT);\n  if (ix > -1) {\n    return [cleaned.slice(0, ix), cleaned.slice(ix).replace(lineCommentSpaces, ';')];\n  }\n  return [cleaned, null];\n}\n\nfunction tokenizeShortcut(shortcut, leadingSymbolMap = SYMBOL_MAP) {\n  const fixLeadingSymbol = (token) => {\n    let work = token;\n    leadingSymbolMap.forEach((currency, symbol) => {\n      if (hasLeadingSymbol(symbol, token)) {\n        work = `${token.slice(1)} ${currency}`;\n      }\n    });\n    return work;\n  };\n\n  // check for comment\n  let [cleaned, comment] = splitComment(shortcut);\n\n  // have to pass over string twice, first time to clean up any\n  // $100 style entries, converting to 100 USD\n  cleaned = utils.splitAndTrim(cleaned)\n        .map(fixLeadingSymbol)\n        .join(' ');\n\n  // The second time, we want to tokenize the string\n  const tokens = utils.splitAndTrim(cleaned);\n\n  // minimal shortcut: \"10 BTC\"\n  if (tokens.length < 2) {\n    console.error(`Invalid shortcut (need 2 parts): ${shortcut}`);\n    throw makeError(\n      TypeError,\n      ERRORS.INVALID_SHORTCUT,\n      `Invalid shortcut (need 2 parts): ${shortcut}`\n    );\n  }\n\n  if (comment) {\n    tokens.push(comment);\n  }\n  return tokens;\n}\n\nclass Entry {\n  /**\n   * Construct using a `props` object that must include the parent transaction\n   * @param {String|Object} shortcut string, or full object\n   * @throws {TypeError} if props cannot be parsed\n   */\n  constructor(props = { }) {\n    const work = RA.isString(props) ? { shortcut: props } : props;\n    const merged = mergeProps(getProps(work));\n    if (!merged.transaction) {\n      console.error(`Invalid Entry, must have a 'transaction', got: ${JSON.stringify(props)}`);\n      throw makeError(\n        TypeError,\n        ERRORS.INVALID_TERM,\n        'Invalid Entry, must have a parent transaction'\n      );\n    }\n\n    if (merged.shortcut && (merged.currency || merged.amount)) {\n      console.error(`Invalid Entry, can't specify a shortcut and currency/amount: ${JSON.stringify(props)}`);\n      throw makeError(\n        TypeError,\n        ERRORS.INVALID_TERM,\n        'Invalid Entry, conflicting shortcut'\n      );\n    }\n\n    KEYS.forEach((key) => {\n      this[key] = merged[key];\n    });\n\n    if (merged.shortcut) {\n      this.applyShortcut(merged.shortcut);\n    }\n\n    if (R.isNil(this.quantity)) {\n      throw makeError(\n        TypeError,\n        ERRORS.INVALID_TERM,\n        'Invalid Entry, no Quantity'\n      );\n    }\n\n    // doesn't hurt to re-wrap if it isn't already a BigNumber\n    this.quantity = new BigNumber(this.quantity);\n  }\n\n  /**\n   * parses a list of entries, which may be objects or strings\n   * @param {Array<Object|String} rawArray input\n   * @param {String} entryType credit or debit\n   */\n  static arrayToEntries(rawArray, entryType, transaction) {\n    return rawArray.map((entry) => {\n      let props;\n      if (RA.isString(entry)) {\n        props = { shortcut: entry, transaction, type: entryType };\n      } else {\n        props = { ...entry, transaction, type: entryType };\n      }\n      return new Entry(props);\n    });\n  }\n\n  /**\n   * Parses a raw object with credits and/or debits array members\n   * Pair posting: debit [@|=] credit\n   * @param {String} shortcut\n   * @return {Array<Entry>} list of entries\n   * @example \"10 BTC\", \"$ 10\", \"10 BTC @ $ 8000\", \"-10 ETH @ .03 BTC\"\n   */\n  static objectToEntries(raw, transaction) {\n    let entries = [];\n    let debits = [];\n    let credits = [];\n    if (hasEntries(raw)) {\n      credits = raw.entries.filter(isCredit);\n      debits = raw.entries.filter(isDebit);\n    }\n\n    if (hasDebits(raw)) {\n      debits = R.concat(debits, raw.debits);\n    }\n    if (hasCredits(raw)) {\n      credits = R.concat(credits, raw.credits);\n    }\n\n    if (debits) {\n      debits = Entry.arrayToEntries(debits, DEBIT, transaction);\n    }\n\n    if (credits) {\n      credits = Entry.arrayToEntries(credits, CREDIT, transaction);\n    }\n\n    return R.concat(debits, credits);\n  }\n\n  /**\n   * Parses an entry \"shortcut\" into balanced Entries.\n   * Shortcut can be in three forms:\n   * - Single posting (credit): \"quantity currency [account]\"\n   *   which will have a balancing debit created for it using the transaction debit account.\n   * - Single posting (debit): \"= quantity currency [account]\"\n   * - Pair posting: debit [@|=] credit\n   *\n   * @param {String} shortcut\n   * @return {Object<string: Array<Posting>>} postings, keyed by \"credits\" and \"debits\"\n   * @throws {TypeError} if shortcut cannot be parsed\n   * @example \"10 BTC\", \"$ 10\", \"10 BTC @ $ 8000\", \"-10 ETH @ .03 BTC\"\n   */\n  static shortcutToEntries(rawShortcut, transaction, leadingSymbolMap = SYMBOL_MAP) {\n    const tokens = tokenizeShortcut(rawShortcut, leadingSymbolMap);\n    let accum = [];\n    let connector = '';\n    let current;\n    let shortcuts = [];\n\n    while (tokens.length > 0) {\n      current = tokens.shift();\n      if (!utils.isConnector(current)) {\n        accum.push(current);\n      } else {\n        if (accum.length > 0) {\n          shortcuts.push(accum);\n        }\n        connector = current;\n        accum = [];\n      }\n    }\n    if (accum.length < 2) {\n      throw makeError(\n        TypeError,\n        ERRORS.INVALID_SHORTCUT,\n        `Invalid shortcut: ${rawShortcut}`\n      );\n    }\n    shortcuts.push(accum);\n\n    if (shortcuts.length === 1) {\n      if (connector !== '=') {\n        // insert a debit at the front, without a specified account\n        // this allows the default action to be from and to the same account\n        // but if one is specified, then that is the credit account.\n        shortcuts = [shortcuts[0].slice(0, 2), shortcuts[0]];\n        connector = '=';\n      } else {\n        // a leading \"=\" connector means that this single-entry is a debit\n        // so add a matching credit.\n        shortcuts = [shortcuts[0], shortcuts[0].slice(0, 2)];\n      }\n    }\n    let ix = 0;\n    let debit;\n    let credit;\n    const entries = [];\n    while (ix < shortcuts.length) {\n      let debitIx = ix;\n      let creditIx = ix + 1;\n\n      const firstAmount = shortcuts[debitIx][0];\n      const negativeFirst = isNegativeString(firstAmount);\n      if (negativeFirst) {\n        // this is a credit, not a debit\n        // take the positive value\n        shortcuts[debitIx][0] = positiveString(firstAmount);\n        // and swap the shortcuts\n        debitIx = ix + 1;\n        creditIx = ix;\n      }\n\n      const catcher = (err) => {\n        console.error(err.message, err.detail);\n        return null;\n      }\n\n      const maker = (props) => new Entry(props);\n\n      const makeEntry = R.tryCatch(maker, catcher);\n\n      debit = makeEntry({\n        shortcut: shortcuts[debitIx].join(' '),\n        transaction,\n        type: DEBIT,\n      });\n      credit = makeEntry({\n        shortcut: shortcuts[creditIx].join(' '),\n        transaction,\n        type: CREDIT,\n      });\n\n      if (credit && debit) {\n        if (negativeFirst) {\n          credit.setPair(debit, connector === '@');\n        } else {\n          debit.setPair(credit, connector === '@');\n        }\n      }\n      if (debit) {\n        entries.push(debit)\n      };\n      if (credit) {\n        entries.push(credit)\n      };\n      ix += 2;\n    }\n    return entries;\n  }\n\n  /**\n   * Parses an one or more entries from a yaml-style \"entry\".\n   * This means it may be:\n   * - A string: shortcut\n   * - An object: with one or both of \"credits\" or \"debits\" fields\n   * @param {Object|String} raw object to parse\n   * @return {Array<Entry>} List of entries parsed\n   */\n  static flexibleToEntries(raw, transaction) {\n    if (RA.isString(raw)) {\n      return Entry.shortcutToEntries(raw, transaction);\n    }\n    if (RA.isObj(raw)) {\n      return Entry.objectToEntries(raw, transaction);\n    }\n    console.error('Invalid Entry', raw);\n    throw makeError(\n      TypeError,\n      ERRORS.INVALID_SHORTCUT,\n      'Invalid Entry: cannot parse'\n    );\n  }\n\n  /**\n   * Parse an entire list of shortcut or object entries and return a list of Entries\n   * @param {Array<Object|String}} entries\n   * @param {Transaction} transaction parent\n   */\n  static makeEntries(entries, transaction) {\n    return R.flatten(entries.map(entry => Entry.flexibleToEntries(entry, transaction)));\n  }\n\n  static tokenizeShortcut (shortcut, leadingSymbolMap) {\n    return tokenizeShortcut(shortcut, leadingSymbolMap);\n  }\n\n  /**\n   * Parse and apply the shortcut to this object.\n   * @param {String} shortcut\n   * @param {Map} leadingSymbols to use, defaulting to {'$': 'USD', '£': 'GBP', '€': EUR'}\n   */\n  applyShortcut(shortcut, leadingSymbolMap = SYMBOL_MAP) {\n    const tokens = Entry.tokenizeShortcut(shortcut, leadingSymbolMap);\n\n    if (lastTokenIsComment(tokens)) {\n      this.note = tokens.pop().slice(1).trim(); // strip leading comment char\n    }\n\n    if (tokens.length > 3) {\n      throw makeError(\n        TypeError,\n        ERRORS.INVALID_SHORTCUT,\n        `Invalid shortcut (unknown extra fields): ${shortcut}`\n      );\n    }\n    // determine which token is the currency\n    let quantity;\n    let currency;\n\n    const numeric1 = utils.looksNumeric(tokens[0]);\n    const numeric2 = utils.looksNumeric(tokens[1]);\n\n    if (tokens.length === 3) {\n      this.account = tokens[2];\n    }\n\n    if (numeric1 && numeric2) {\n      throw makeError(\n        TypeError,\n        ERRORS.INVALID_SHORTCUT,\n        `Invalid Posting, two numeric in shortcut: ${shortcut}`\n      );\n    }\n\n    if (!(numeric1 || numeric2)) {\n      throw makeError(\n        TypeError,\n        ERRORS.INVALID_SHORTCUT,\n        `Invalid Posting, no numeric in shortcut: ${shortcut}`\n      );\n    }\n\n    if (numeric1) {\n      [quantity, currency] = tokens;\n    } else {\n      [currency, quantity] = tokens;\n    }\n\n    quantity = quantity.replace(commaRe, '');\n    this.quantity = BigNumber(quantity);\n    this.currency = currency;\n  }\n\n  /**\n   * Add this entry to the correct account.\n   * @param {Accounts} Accounts\n   * @return {Account} account for this entry\n   */\n  applyToAccount(accounts) {\n    let acct;\n    try {\n      acct = accounts.get(this.getAccountPath());\n      acct.addEntry(this);\n    } catch (e) {\n      if (e.message === ERRORS.NOT_FOUND) {\n        console.error(`Warning, invalid journal, missing account ${this.getAccountPath()}`);\n      }\n    }\n    return acct;\n  }\n\n  equals(entry) {\n    return (\n      entry\n        && R.is(Entry, entry)\n        && this.quantity.eq(entry.quantity)\n        && this.currency === entry.currency\n        && this.type === entry.type\n    );\n  }\n\n  /**\n   * Get the account for this entry, defaulting to the transaction account for this\n   * type if not directly set.\n   * @return {Account} Account\n   */\n  getAccount() {\n    return this.account || this.transaction.account[this.type];\n  }\n\n  /**\n   * Return the account path\n   * @throws {TypeError} if none\n   */\n  getAccountPath() {\n    const account = this.getAccount();\n    if (!account) {\n      console.error('no account!', this);\n      throw makeError(\n        TypeError,\n        ERRORS.INVALID_SHORTCUT,\n        'invalid account path'\n      );\n    }\n    if (RA.isString(account)) {\n      return account;\n    }\n    return account.path;\n  }\n\n  /**\n   * Get the amount remaining of this credit, not yet applied to lots.\n   * @return {BigNumber} amount remaining\n   */\n  getLotCreditRemaining() {\n    if (this.TYPE === DEBIT) {\n      return BIG_0;\n    }\n\n    const credits = addBigNumbers(getLotCredits(this.currency, this.lots));\n    return this.quantity.minus(credits);\n  }\n\n  /**\n   * Get a shortcut for this entry.  If it is a debit and has a credit, then add that to the shortcut.\n   */\n  getFullShortcut() {\n    if (this.type === DEBIT && this.pair && !(this.pair.quantity.eq(this.quantity) && this.pair.currency === this.currency)) {\n      return `${this.shortcut} @ ${this.pair.shortcut}`;\n    }\n    return this.shortcut;\n  }\n\n  /**\n   * Get the date for this entry, defaulting to the transaction date if not directly set.\n   * @return {Moment} date\n   */\n  getUtc() {\n    return this.transaction.utc;\n  }\n\n  /**\n   * Apply as much as possible of our remaining credit amount to the specified lot.\n   * @param {Lot} lot\n   * @param {BigNumber} maximum to apply\n   * @return {BigNumber} how much was applied to the lot\n   */\n  setLot(lot, maxQuantity) {\n    let applied = this.quantity;\n    if (this.type === CREDIT) {\n      const remainingLot = lot.getRemaining();\n      const remainingCredit = this.getLotCreditRemaining();\n      applied = BigNumber.min(remainingCredit, remainingLot, maxQuantity);\n      /* console.log(`rl = ${remainingLot.toFixed(2)}\n         rc = ${remainingCredit.toFixed(2)}\n         max = ${maxQuantity.toFixed(2)}\n         ap = ${applied}`); */\n    }\n    if (applied.gt(BIG_0)) {\n      this.lots.push({ lot, applied });\n    }\n    return applied;\n  }\n\n  /**\n   * Test whether this entry is in the specified account or one of its parents.\n   * @param {String} path\n   * @return {Boolean} true if found\n   */\n  inAccount(path) {\n    const acct = this.getAccount();\n    if (RA.isString(acct)) {\n      return RA.contained(acct.split(':'), path);\n    }\n    return acct.inPath(path);\n  }\n\n  /**\n   * Test whether this entry has a proper balancing entry.\n   * @return {Boolean} true if balanced\n   */\n  isBalanced() {\n    return !!(this.pair && (\n      this.pair.currency !== this.currency\n        || this.pair.getAccount() !== this.getAccount()\n    ));\n  }\n\n  /**\n   * Test whether this is a balancing entry.\n   * @return {Boolean} true if balancing\n   */\n  isBalancingEntry() {\n    return this.balancing && this.virtual;\n  }\n\n  /**\n   * Make a balancing pair entry.\n   * @param {Account} account\n   * @return {Entry} new pair entry\n   */\n  makeBalancingClone(account) {\n    this.balancing = new Entry({\n      transaction: this.transaction,\n      quantity: this.quantity,\n      currency: this.currency,\n      account: account.path,\n      type: this.type === CREDIT ? DEBIT : CREDIT,\n      balancing: this,\n      virtual: true,\n    });\n    return this.balancing;\n  }\n\n  /**\n   * Multiplies the current quantity by the quantity in the passed `Posting`.\n   * @param {Posting} posting\n   * @return {Posting} this\n   */\n  multiplyBy(posting) {\n    this.quantity = this.quantity.times(posting.quantity);\n    return this;\n  }\n\n  /**\n   * Set the \"other side\" of the entry on this and its partner.\n   * @param {Entry} other side (credit if this is debit, debit if this is credit)\n   * @param {Boolean} true if the price is specified as \"per each\"\n   */\n  setPair(partner, priceEach) {\n    this.pair = partner;\n    if (priceEach) {\n      // price specified as 'each', so it needs to be multiplied by\n      // this quantity\n      partner.multiplyBy(this);\n    }\n    if (partner.pair !== this) {\n      // set the partner, but don't multiply\n      partner.setPair(this, false);\n    }\n  }\n\n  /**\n   * Get a representation of this object useful for logging or converting to yaml\n   * @param {options} object with optional \"shallow\" and \"yaml\" fields\n   * @return {Object<String, *>}\n   */\n  toObject(options = {}) {\n    const {shallow, yaml} = options;\n    const props = {\n      id: this.id,\n      quantity: this.quantity.toFixed(8),\n      currency: this.currency,\n      account: this.getAccountPath(),\n      type: this.type,\n      note: this.note,\n      virtual: this.virtual,\n    };\n\n    if (!yaml) {\n      props.pair = (!this.pair || shallow) ? null : this.pair.toObject({ yaml, shallow: true});\n      props.balancing = (!this.balancing || shallow) ? null : this.balancing.toObject({ yaml, shallow: true });\n      props.lots = shallow ? null : describeLots(this.lots);\n    }\n\n    return utils.stripFalsy(props);\n  }\n\n  toString() {\n    return `Entry (${this.type}): ${this.quantity.toFixed(8)} ${this.currency} ${this.getAccount()}`;\n  }\n}\n\nmodule.exports = Entry;\n"
  ]
}
