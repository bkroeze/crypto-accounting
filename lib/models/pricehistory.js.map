{
  "version": 3,
  "sources": [
    "pricehistory.js"
  ],
  "names": [
    "SortedArray",
    "require",
    "Moment",
    "R",
    "RA",
    "PairPrice",
    "dates",
    "arrayToObjects",
    "ERRORS",
    "makeError",
    "CurrencyPrices",
    "PriceHistory",
    "constructor",
    "pricelist",
    "pairs",
    "isArray",
    "forEach",
    "p",
    "price",
    "has",
    "pair",
    "insert",
    "Object",
    "keys",
    "key",
    "priceProps",
    "derivePrice",
    "utc",
    "base",
    "quote",
    "transCurrencies",
    "within",
    "chain",
    "quoteStatus",
    "transStatus",
    "transCurrency",
    "i",
    "length",
    "hasPair",
    "push",
    "findPrice",
    "averageDates",
    "rate",
    "times",
    "setTranslationChain",
    "RangeError",
    "NOT_FOUND",
    "status",
    "getPair",
    "findNearest",
    "invert",
    "toObject",
    "options",
    "rv",
    "keysIn",
    "module",
    "exports"
  ],
  "mappings": "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",
  "file": "pricehistory.js",
  "sourceRoot": "../../src/models",
  "sourcesContent": [
    "const SortedArray = require('sorted-array');\nconst Moment = require('moment');\nconst R = require('ramda');\nconst RA = require('ramda-adjunct');\n\nconst PairPrice = require('./pairprice');\nconst dates = require('../utils/dates');\nconst { arrayToObjects } = require('../utils/models');\nconst { ERRORS } = require('./constants');\nconst { makeError } = require('../utils/errors');\nconst CurrencyPrices = require('./currencyprices');\n\n/**\n * A collection of prices for multiple currencies.\n */\nclass PriceHistory {\n  /**\n   * Instantiate via a raw list of prices\n   * @param {Array<String|Object>} raw prices\n   */\n  constructor(pricelist) {\n    this.pairs = {};\n    if (pricelist) {\n      if (RA.isArray(pricelist)) {\n        pricelist.forEach((p) => {\n          const price = new PairPrice(p);\n          if (!R.has(price.pair, this.pairs)) {\n            this.pairs[price.pair] = new CurrencyPrices();\n          }\n          this.pairs[price.pair].insert(price);\n        });\n      } else {\n        Object.keys(pricelist).forEach((key) => {\n          this.pairs[key] = new CurrencyPrices();\n          pricelist[key].forEach((priceProps) => {\n            this.pairs[key].insert(new PairPrice(priceProps));\n          });\n        });\n      }\n\n    }\n  }\n\n  /**\n   * Get the best price possible by following a chain of translations.\n   * @param {String|Moment|Object} utc\n   * @param {String} base currency\n   * @param {String} quote currency - the rate refers to this many of this currency for 1 base\n   * @param {Array} currencies to use as translations for derivation\n   * @param {Integer} within seconds (no limit if not given or null)\n   * @return {PairPrice}\n   * @throws {RangeError} with code \"ERR_DISTANCE\" if nearest is out of range\n   * @throws {RangeError} with code \"ERR_NOT_FOUND\" if pair is not present and cannot be derived\n   */\n  derivePrice(utc, base, quote, transCurrencies = ['BTC', 'ETH'], within = null) {\n    if (transCurrencies) {\n      const chain = [];\n      let quoteStatus;\n      let transStatus;\n      let transCurrency;\n      let i;\n\n      for (i = 0; i < transCurrencies.length; i++) {\n        transCurrency = transCurrencies[i];\n        quoteStatus = this.hasPair(transCurrency, quote);\n        // console.log(`qs hasPair(${transCurrency}/${quote}) = ${quoteStatus}`);\n        transStatus = this.hasPair(transCurrency, base);\n        // console.log(`bs hasPair(${transCurrency}/${quote}) = ${transStatus}`);\n        if (quoteStatus !== 0 && transStatus !== 0) {\n          // great, we found the same base to use as translation\n          // now get the relevant prices\n          chain.push(this.findPrice(utc, base, transCurrency, null, within));\n          chain.push(this.findPrice(utc, transCurrency, quote, null, within));\n          break;\n        }\n      }\n\n      if (chain.length > 1) {\n        const price = new PairPrice({\n          utc: dates.averageDates(chain[0].utc, chain[1].utc),\n          base,\n          quote,\n          rate: chain[0].rate.times(chain[1].rate),\n        });\n        price.setTranslationChain(chain);\n        return price;\n      }\n    }\n\n    throw makeError(RangeError, ERRORS.NOT_FOUND, `${base}/${quote}`);\n  }\n\n  /**\n   * Find the nearest price for the given currency pair\n   * @param {String|Moment|Object} utc\n   * @param {String} base currency\n   * @param {String} quote currency - the rate refers to this many of this currency for 1 base\n   * @param {Array} currencies to use as bases for derivation\n   * @param {Integer} within seconds (no limit if not given or null)\n   * @return {PairPrice}\n   * @throws {RangeError} with code \"ERR_DISTANCE\" if nearest is out of range\n   * @throws {RangeError} with code \"ERR_NOT_FOUND\" if pair is not present and cannot be derived\n   */\n  findPrice(utc, base, quote, transCurrencies = ['BTC', 'ETH'], within = null) {\n    const status = this.hasPair(base, quote);\n    if (status === -1) {\n      return this.getPair(quote, base).findNearest(utc).invert();\n    }\n    if (status === 1) {\n      return this.pairs[`${base}/${quote}`].findNearest(utc);\n    }\n    return this.derivePrice(utc, base, quote, transCurrencies, within);\n  }\n\n  /**\n   * Get the prices for a pair\n   * @param {String} base\n   * @param {String} quote\n   * @return {CurrencyPrices} prices\n   */\n  getPair(base, quote) {\n    return this.pairs[`${base}/${quote}`];\n  }\n\n  /**\n   * Test whether we have a pair, or its inverse\n   * @param {String} base\n   * @param {String} quote\n   * @reurn {Integer} 0 = false, 1 = true, -1 = true but inverse\n   */\n  hasPair(base, quote) {\n    if (base === quote) {\n      return 0;\n    }\n    if (R.has(`${base}/${quote}`, this.pairs)) {\n      return 1;\n    }\n    if (R.has(`${quote}/${base}`, this.pairs)) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Get a representation of this object useful for logging or converting to yaml\n   * @return {Object<String, *>}\n   */\n  toObject(options) {\n    const rv = {};\n    R.keysIn(this.pairs).forEach((key) => {\n      rv[key] = arrayToObjects(this.pairs[key], options);\n    });\n    return rv;\n  }\n}\n\nmodule.exports = PriceHistory;\n"
  ]
}
