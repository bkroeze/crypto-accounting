{
  "version": 3,
  "sources": [
    "pricehistory.js"
  ],
  "names": [
    "SortedArray",
    "require",
    "Moment",
    "R",
    "RA",
    "PairPrice",
    "dates",
    "arrayToObjects",
    "ERRORS",
    "makeError",
    "CurrencyPrices",
    "PriceHistory",
    "constructor",
    "pricelist",
    "pairs",
    "forEach",
    "p",
    "price",
    "has",
    "pair",
    "insert",
    "derivePrice",
    "utc",
    "base",
    "quote",
    "transCurrencies",
    "within",
    "chain",
    "quoteStatus",
    "transStatus",
    "transCurrency",
    "i",
    "length",
    "hasPair",
    "push",
    "findPrice",
    "averageDates",
    "rate",
    "times",
    "setTranslationChain",
    "RangeError",
    "NOT_FOUND",
    "status",
    "getPair",
    "findNearest",
    "invert",
    "toObject",
    "rv",
    "keysIn",
    "key",
    "module",
    "exports"
  ],
  "mappings": "AAAA,MAAMA,cAAcC,QAAQ,cAAR,CAApB;AACA,MAAMC,SAASD,QAAQ,QAAR,CAAf;AACA,MAAME,IAAIF,QAAQ,OAAR,CAAV;AACA,MAAMG,KAAKH,QAAQ,eAAR,CAAX;;AAEA,MAAMI,YAAYJ,QAAQ,aAAR,CAAlB;AACA,MAAMK,QAAQL,QAAQ,gBAAR,CAAd;AACA,MAAM,EAAEM,cAAF,KAAqBN,QAAQ,iBAAR,CAA3B;AACA,MAAM,EAAEO,MAAF,KAAaP,QAAQ,aAAR,CAAnB;AACA,MAAM,EAAEQ,SAAF,KAAgBR,QAAQ,iBAAR,CAAtB;AACA,MAAMS,iBAAiBT,QAAQ,kBAAR,CAAvB;;AAEA;;;AAGA,MAAMU,YAAN,CAAmB;AACjB;;;;AAIAC,cAAYC,SAAZ,EAAuB;AACrB,SAAKC,KAAL,GAAa,EAAb;AACA,QAAID,SAAJ,EAAe;AACbA,gBAAUE,OAAV,CAAmBC,CAAD,IAAO;AACvB,cAAMC,QAAQ,IAAIZ,SAAJ,CAAcW,CAAd,CAAd;AACA,YAAI,CAACb,EAAEe,GAAF,CAAMD,MAAME,IAAZ,EAAkB,KAAKL,KAAvB,CAAL,EAAoC;AAClC,eAAKA,KAAL,CAAWG,MAAME,IAAjB,IAAyB,IAAIT,cAAJ,EAAzB;AACD;AACD,aAAKI,KAAL,CAAWG,MAAME,IAAjB,EAAuBC,MAAvB,CAA8BH,KAA9B;AACD,OAND;AAOD;AACF;;AAED;;;;;;;;;;;AAWAI,cAAYC,GAAZ,EAAiBC,IAAjB,EAAuBC,KAAvB,EAA8BC,kBAAkB,CAAC,KAAD,EAAQ,KAAR,CAAhD,EAAgEC,SAAS,IAAzE,EAA+E;AAC7E,QAAID,eAAJ,EAAqB;AACnB,YAAME,QAAQ,EAAd;AACA,UAAIC,WAAJ;AACA,UAAIC,WAAJ;AACA,UAAIC,aAAJ;AACA,UAAIC,CAAJ;;AAEA,WAAKA,IAAI,CAAT,EAAYA,IAAIN,gBAAgBO,MAAhC,EAAwCD,GAAxC,EAA6C;AAC3CD,wBAAgBL,gBAAgBM,CAAhB,CAAhB;AACAH,sBAAc,KAAKK,OAAL,CAAaH,aAAb,EAA4BN,KAA5B,CAAd;AACA;AACAK,sBAAc,KAAKI,OAAL,CAAaH,aAAb,EAA4BP,IAA5B,CAAd;AACA;AACA,YAAIK,gBAAgB,CAAhB,IAAqBC,gBAAgB,CAAzC,EAA4C;AAC1C;AACA;AACAF,gBAAMO,IAAN,CAAW,KAAKC,SAAL,CAAeb,GAAf,EAAoBC,IAApB,EAA0BO,aAA1B,EAAyC,IAAzC,EAA+CJ,MAA/C,CAAX;AACAC,gBAAMO,IAAN,CAAW,KAAKC,SAAL,CAAeb,GAAf,EAAoBQ,aAApB,EAAmCN,KAAnC,EAA0C,IAA1C,EAAgDE,MAAhD,CAAX;AACA;AACD;AACF;;AAED,UAAIC,MAAMK,MAAN,GAAe,CAAnB,EAAsB;AACpB,cAAMf,QAAQ,IAAIZ,SAAJ,CAAc;AAC1BiB,eAAKhB,MAAM8B,YAAN,CAAmBT,MAAM,CAAN,EAASL,GAA5B,EAAiCK,MAAM,CAAN,EAASL,GAA1C,CADqB;AAE1BC,cAF0B;AAG1BC,eAH0B;AAI1Ba,gBAAMV,MAAM,CAAN,EAASU,IAAT,CAAcC,KAAd,CAAoBX,MAAM,CAAN,EAASU,IAA7B;AAJoB,SAAd,CAAd;AAMApB,cAAMsB,mBAAN,CAA0BZ,KAA1B;AACA,eAAOV,KAAP;AACD;AACF;;AAED,UAAMR,UAAU+B,UAAV,EAAsBhC,OAAOiC,SAA7B,EAAyC,GAAElB,IAAK,IAAGC,KAAM,EAAzD,CAAN;AACD;;AAED;;;;;;;;;;;AAWAW,YAAUb,GAAV,EAAeC,IAAf,EAAqBC,KAArB,EAA4BC,kBAAkB,CAAC,KAAD,EAAQ,KAAR,CAA9C,EAA8DC,SAAS,IAAvE,EAA6E;AAC3E,UAAMgB,SAAS,KAAKT,OAAL,CAAaV,IAAb,EAAmBC,KAAnB,CAAf;AACA,QAAIkB,WAAW,CAAC,CAAhB,EAAmB;AACjB,aAAO,KAAKC,OAAL,CAAanB,KAAb,EAAoBD,IAApB,EAA0BqB,WAA1B,CAAsCtB,GAAtC,EAA2CuB,MAA3C,EAAP;AACD;AACD,QAAIH,WAAW,CAAf,EAAkB;AAChB,aAAO,KAAK5B,KAAL,CAAY,GAAES,IAAK,IAAGC,KAAM,EAA5B,EAA+BoB,WAA/B,CAA2CtB,GAA3C,CAAP;AACD;AACD,WAAO,KAAKD,WAAL,CAAiBC,GAAjB,EAAsBC,IAAtB,EAA4BC,KAA5B,EAAmCC,eAAnC,EAAoDC,MAApD,CAAP;AACD;;AAED;;;;;;AAMAiB,UAAQpB,IAAR,EAAcC,KAAd,EAAqB;AACnB,WAAO,KAAKV,KAAL,CAAY,GAAES,IAAK,IAAGC,KAAM,EAA5B,CAAP;AACD;;AAED;;;;;;AAMAS,UAAQV,IAAR,EAAcC,KAAd,EAAqB;AACnB,QAAID,SAASC,KAAb,EAAoB;AAClB,aAAO,CAAP;AACD;AACD,QAAIrB,EAAEe,GAAF,CAAO,GAAEK,IAAK,IAAGC,KAAM,EAAvB,EAA0B,KAAKV,KAA/B,CAAJ,EAA2C;AACzC,aAAO,CAAP;AACD;AACD,QAAIX,EAAEe,GAAF,CAAO,GAAEM,KAAM,IAAGD,IAAK,EAAvB,EAA0B,KAAKT,KAA/B,CAAJ,EAA2C;AACzC,aAAO,CAAC,CAAR;AACD;AACD,WAAO,CAAP;AACD;;AAED;;;;AAIAgC,aAAW;AACT,UAAMC,KAAK,EAAX;AACA5C,MAAE6C,MAAF,CAAS,KAAKlC,KAAd,EAAqBC,OAArB,CAA8BkC,GAAD,IAAS;AACpCF,SAAGE,GAAH,IAAU1C,eAAe,KAAKO,KAAL,CAAWmC,GAAX,CAAf,CAAV;AACD,KAFD;AAGA,WAAOF,EAAP;AACD;AAhIgB;;AAmInBG,OAAOC,OAAP,GAAiBxC,YAAjB",
  "file": "pricehistory.js",
  "sourceRoot": "../../src/models",
  "sourcesContent": [
    "const SortedArray = require('sorted-array');\nconst Moment = require('moment');\nconst R = require('ramda');\nconst RA = require('ramda-adjunct');\n\nconst PairPrice = require('./pairprice');\nconst dates = require('../utils/dates');\nconst { arrayToObjects } = require('../utils/models');\nconst { ERRORS } = require('./constants');\nconst { makeError } = require('../utils/errors');\nconst CurrencyPrices = require('./currencyprices');\n\n/**\n * A collection of prices for multiple currencies.\n */\nclass PriceHistory {\n  /**\n   * Instantiate via a raw list of prices\n   * @param {Array<String|Object>} raw prices\n   */\n  constructor(pricelist) {\n    this.pairs = {};\n    if (pricelist) {\n      pricelist.forEach((p) => {\n        const price = new PairPrice(p);\n        if (!R.has(price.pair, this.pairs)) {\n          this.pairs[price.pair] = new CurrencyPrices();\n        }\n        this.pairs[price.pair].insert(price);\n      });\n    }\n  }\n\n  /**\n   * Get the best price possible by following a chain of translations.\n   * @param {String|Moment|Object} utc\n   * @param {String} base currency\n   * @param {String} quote currency - the rate refers to this many of this currency for 1 base\n   * @param {Array} currencies to use as translations for derivation\n   * @param {Integer} within seconds (no limit if not given or null)\n   * @return {PairPrice}\n   * @throws {RangeError} with code \"ERR_DISTANCE\" if nearest is out of range\n   * @throws {RangeError} with code \"ERR_NOT_FOUND\" if pair is not present and cannot be derived\n   */\n  derivePrice(utc, base, quote, transCurrencies = ['BTC', 'ETH'], within = null) {\n    if (transCurrencies) {\n      const chain = [];\n      let quoteStatus;\n      let transStatus;\n      let transCurrency;\n      let i;\n\n      for (i = 0; i < transCurrencies.length; i++) {\n        transCurrency = transCurrencies[i];\n        quoteStatus = this.hasPair(transCurrency, quote);\n        // console.log(`qs hasPair(${transCurrency}/${quote}) = ${quoteStatus}`);\n        transStatus = this.hasPair(transCurrency, base);\n        // console.log(`bs hasPair(${transCurrency}/${quote}) = ${transStatus}`);\n        if (quoteStatus !== 0 && transStatus !== 0) {\n          // great, we found the same base to use as translation\n          // now get the relevant prices\n          chain.push(this.findPrice(utc, base, transCurrency, null, within));\n          chain.push(this.findPrice(utc, transCurrency, quote, null, within));\n          break;\n        }\n      }\n\n      if (chain.length > 1) {\n        const price = new PairPrice({\n          utc: dates.averageDates(chain[0].utc, chain[1].utc),\n          base,\n          quote,\n          rate: chain[0].rate.times(chain[1].rate),\n        });\n        price.setTranslationChain(chain);\n        return price;\n      }\n    }\n\n    throw makeError(RangeError, ERRORS.NOT_FOUND, `${base}/${quote}`);\n  }\n\n  /**\n   * Find the nearest price for the given currency pair\n   * @param {String|Moment|Object} utc\n   * @param {String} base currency\n   * @param {String} quote currency - the rate refers to this many of this currency for 1 base\n   * @param {Array} currencies to use as bases for derivation\n   * @param {Integer} within seconds (no limit if not given or null)\n   * @return {PairPrice}\n   * @throws {RangeError} with code \"ERR_DISTANCE\" if nearest is out of range\n   * @throws {RangeError} with code \"ERR_NOT_FOUND\" if pair is not present and cannot be derived\n   */\n  findPrice(utc, base, quote, transCurrencies = ['BTC', 'ETH'], within = null) {\n    const status = this.hasPair(base, quote);\n    if (status === -1) {\n      return this.getPair(quote, base).findNearest(utc).invert();\n    }\n    if (status === 1) {\n      return this.pairs[`${base}/${quote}`].findNearest(utc);\n    }\n    return this.derivePrice(utc, base, quote, transCurrencies, within);\n  }\n\n  /**\n   * Get the prices for a pair\n   * @param {String} base\n   * @param {String} quote\n   * @return {CurrencyPrices} prices\n   */\n  getPair(base, quote) {\n    return this.pairs[`${base}/${quote}`];\n  }\n\n  /**\n   * Test whether we have a pair, or its inverse\n   * @param {String} base\n   * @param {String} quote\n   * @reurn {Integer} 0 = false, 1 = true, -1 = true but inverse\n   */\n  hasPair(base, quote) {\n    if (base === quote) {\n      return 0;\n    }\n    if (R.has(`${base}/${quote}`, this.pairs)) {\n      return 1;\n    }\n    if (R.has(`${quote}/${base}`, this.pairs)) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Get a representation of this object useful for logging or converting to yaml\n   * @return {Object<String, *>}\n   */\n  toObject() {\n    const rv = {};\n    R.keysIn(this.pairs).forEach((key) => {\n      rv[key] = arrayToObjects(this.pairs[key]);\n    });\n    return rv;\n  }\n}\n\nmodule.exports = PriceHistory;\n"
  ]
}
