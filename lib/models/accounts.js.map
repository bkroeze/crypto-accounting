{
  "version": 3,
  "sources": [
    "accounts.js"
  ],
  "names": [
    "R",
    "require",
    "Account",
    "Lot",
    "CREDIT",
    "ERRORS",
    "utils",
    "makeError",
    "BIG_0",
    "fifoSearch",
    "find",
    "lifoSearch",
    "findLast",
    "getAccountPathMap",
    "accounts",
    "pathMap",
    "valuesIn",
    "forEach",
    "account",
    "path",
    "isEmpty",
    "children",
    "merge",
    "Accounts",
    "constructor",
    "lots",
    "keysIn",
    "aliases",
    "paths",
    "asList",
    "calculatePaths",
    "keys",
    "sort",
    "map",
    "k",
    "a",
    "createBalancingEntries",
    "getBalancing",
    "balancingAccount",
    "get",
    "getBalancingAccount",
    "e",
    "console",
    "error",
    "message",
    "Object",
    "filter",
    "accountFilter",
    "fn",
    "values",
    "key",
    "is",
    "Array",
    "join",
    "val",
    "getAlias",
    "getPath",
    "ReferenceError",
    "NOT_FOUND",
    "alias",
    "hasBalancingAccount",
    "getLots",
    "currencies",
    "force",
    "lifo",
    "search",
    "length",
    "flatten",
    "compare",
    "isTrade",
    "entry",
    "isBalancingEntry",
    "currency",
    "isFiat",
    "pair",
    "applyCreditToLots",
    "c",
    "findLot",
    "l",
    "isOpen",
    "qty",
    "quantity",
    "gt",
    "lot",
    "RangeError",
    "EXHAUSTED",
    "applied",
    "addCredit",
    "minus",
    "isNotVirtualAccount",
    "getEntries",
    "has",
    "toObject",
    "options",
    "objectValsToObject",
    "module",
    "exports"
  ],
  "mappings": "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",
  "file": "accounts.js",
  "sourceRoot": "../../src/models",
  "sourcesContent": [
    "const R = require('ramda');\n\nconst Account = require('./account');\nconst Lot = require('./lot');\nconst { CREDIT, ERRORS } = require('./constants');\nconst utils = require('../utils/models');\nconst { makeError } = require('../utils/errors');\nconst { BIG_0 } = require('../utils/numbers');\n\nconst fifoSearch = R.find;\nconst lifoSearch = R.findLast;\n\n/**\n * Get all accounts, keyed by full path\n * @param {Object<String, Account>} accounts\n * @return {Object<String, Account>} map\n */\nfunction getAccountPathMap(accounts) {\n  let pathMap = {};\n\n  R.valuesIn(accounts).forEach((account) => {\n    pathMap[account.path] = account;\n    if (!R.isEmpty(account.children)) {\n      pathMap = R.merge(pathMap, getAccountPathMap(account.children));\n    }\n  });\n  return pathMap;\n}\n\n/**\n * A container class for a group of accounts.\n */\nclass Accounts {\n  /**\n   * Constructor\n   * @param {Array<Object>} accounts in raw 'props' format\n   */\n  constructor(accounts) {\n    this.accounts = accounts;\n    this.lots = [];\n    R.keysIn(accounts).forEach((path) => {\n      this.accounts[path] = new Account(R.merge(accounts[path], { path }));\n    });\n    this.aliases = {};\n    this.paths = {};\n  }\n\n  /**\n   * Lazily get all accounts as an array, sorted by path.\n   * @return {Array<Account>} accounts\n   */\n  asList() {\n    if (R.isEmpty(this.paths)) {\n      this.calculatePaths();\n    }\n    const keys = R.keysIn(this.paths);\n    keys.sort();\n    return keys.map(k => this.paths[k]);\n  }\n\n  /**\n   * Build the path account map, for faster lookup later.\n   */\n  calculatePaths() {\n    this.paths = getAccountPathMap(this.accounts);\n    const aliases = {};\n\n    R.valuesIn(this.paths).forEach((account) => {\n      if (account.aliases) {\n        account.aliases.forEach((a) => {\n          aliases[a] = account;\n        });\n      }\n    });\n    this.aliases = aliases;\n    return this;\n  }\n\n  /**\n   * Go through all balancing accounts, and create balancing (virtual) entries for them.\n   */\n  createBalancingEntries() {\n    if (R.isEmpty(this.paths)) {\n      this.calculatePaths();\n    }\n    this.getBalancing().forEach((account) => {\n      try {\n        const balancingAccount = this.get(account.getBalancingAccount());\n        account.createBalancingEntries(balancingAccount);\n      } catch (e) {\n        console.error(`${e.message}\\nAccounts: ${Object.keys(this.paths)}`);\n        throw e;\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Get a list of all accounts and subaccounts matching the filter, in a flat list\n   * @param {Function} filter\n   */\n  filter(accountFilter) {\n    const accounts = this.asList();\n    if (!accountFilter) {\n      return accounts;\n    }\n    return accounts.filter(accountFilter);\n  }\n\n  /**\n   * Apply a function to each account.\n   * @param {Function } fn\n   */\n  forEach(fn) {\n    Object.values(this.accounts).forEach(fn);\n  }\n\n  /**\n   * Get an account by alias or key\n   * @param {String} alias or key\n   * @return {Account} account\n   * @throws {ReferenceError} if not found\n   */\n  get(key) {\n    const path = (R.is(Array, key)) ? key.join(':') : key;\n    let val = this.getAlias(path);\n    if (!val) {\n      val = this.getPath(path);\n    }\n    if (!val) {\n      throw makeError(\n        ReferenceError,\n        ERRORS.NOT_FOUND,\n        path);\n    }\n    return val;\n  }\n\n  /**\n   * Get an account by alias.\n   * @param {String} alias\n   * @return {Account} account\n   */\n  getAlias(alias) {\n    if (R.isEmpty(this.aliases)) {\n      this.calculatePaths();\n    }\n    return this.aliases[alias];\n  }\n\n  /**\n   * Get all balancing accounts.\n   * @return {Array<Account>} accounts\n   */\n  getBalancing() {\n    return this.filter(Account.hasBalancingAccount);\n  }\n\n  /**\n   * Lazily calculate all lots for all transactions in all accounts.\n   * @param {Object<String,Currency>} currencies\n   * @param {Boolean} force recalculation if true\n   * @param {Boolean} lifo use lifo instead of the default fifo strategy if true\n   * @return {Array<Lot>} lots\n   */\n  getLots(currencies, force, lifo) {\n    const search = lifo ? lifoSearch : fifoSearch;\n    if (force || this.lots.length === 0) {\n      const lots = R.flatten(this.map(a => a.getLots(currencies, force)));\n      lots.sort(Lot.compare);\n      // we've got lots, now go through credits for all accounts and apply\n\n      const isTrade = (entry) => {\n        if (entry.isBalancingEntry()) {\n          return false;\n        }\n        const currency = currencies[entry.currency];\n        // console.log(`isNotFiat: ${entry.currency}, ${currency ? 'found' : 'missing'}`);\n        if (!currency || currency.isFiat()) {\n          return false;\n        }\n        return entry.pair && entry.currency !== entry.pair.currency;\n      };\n\n      const applyCreditToLots = (c) => {\n        const findLot = l => (l.currency === c.currency && l.isOpen());\n        let qty = c.quantity;\n        while (qty.gt(BIG_0)) {\n          // console.log('-- qty now', qty.toFixed(2));\n          const lot = search(findLot, lots);\n          if (!lot) {\n            throw makeError(RangeError, ERRORS.EXHAUSTED, `Ran out of lots looking for ${c.currency}`);\n          }\n          // console.log('going to add to', lot.toObject());\n          const applied = lot.addCredit(c, qty);\n          // console.log(`applied ${applied.toFixed(2)}`);\n          qty = qty.minus(applied);\n        }\n      };\n\n      this.asList()\n        .filter(Account.isNotVirtualAccount)\n        .forEach((a) => {\n          a.getEntries(CREDIT)\n            .filter(isTrade)\n            .forEach(applyCreditToLots);\n        });\n      this.lots = lots;\n    }\n    return this.lots;\n  }\n\n  /**\n   * Get an account by path.\n   * @param {String} path\n   * @return {Account} account\n   */\n  getPath(path) {\n    if (R.isEmpty(this.paths)) {\n      this.calculatePaths();\n    }\n    return this.paths[path];\n  }\n\n  has(path) {\n    try {\n      if (this.get(path)) {\n        return true;\n      }\n    } catch (e) {\n      //pass\n    }\n    return false;\n  }\n\n  /**\n   * Check to see if it is populated.\n   * return {Boolean} true if no accounts\n   */\n  isEmpty() {\n    return R.isEmpty(this.accounts);\n  }\n\n  /**\n   * Apply a function to all accounts.\n   * @param {Function} function to apply\n   */\n  map(fn) {\n    const accounts = this.asList();\n    if (!fn) {\n      return accounts;\n    }\n    return accounts.map(fn);\n  }\n\n  /**\n   * Get a representation of this object useful for logging or converting to yaml\n}   * @return {Object<String, Object>}\n   */\n  toObject(options = {}) {\n    return utils.objectValsToObject(this.accounts, options);\n  }\n}\n\nmodule.exports = Accounts;\n"
  ]
}
